from copy import deepcopy


# Изначальный массив
matrix = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
    [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
    [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
    [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

# Определяем, что является чернилами
ink = 1 if sum(sum(i) for i in matrix) < (len(matrix) * len(matrix[0])) // 2 else 0

# Это только для красоты. Меняем чернила на 8, а фон на .
for y in range(len(matrix)):
    for x in range(len(matrix[y])):
        matrix[y][x] = 8 if matrix[y][x] == ink else '.'

# Печать матрицы
for j in matrix:
    print(*j)
print()

matrix_copy = deepcopy(matrix)

# Функция, проверяющая является ли значение (x, y) точкой контура
def is_contour_point(x, y, matrix):
    # Проверяем, что точка (x, y) не находится на краю матрицы
    if (y == 0) or (y == len(matrix) - 1) or (x == 0) or (x == len(matrix[0]) - 1):
        return False
    # Проверяем, все ли соседи (x, y) принадлежат объекту
    return (matrix[y - 1][x] == 8) and (matrix[y + 1][x] == 8) and (matrix[y][x - 1] == 8) and (matrix[y][x + 1] == 8)


# Находим контур объекта
for y in range(len(matrix)):
    for x in range(len(matrix[0])):
        if matrix[y][x] == 8 and is_contour_point(x, y, matrix):
            matrix_copy[y][x] = '.'

# Печать матрицы
for j in matrix_copy:
    print(*j)
print()


def spiral(x, y, n):
    """ Это функция генератор, ее надо инициализировать и далее с помощью оператора next получать координаты
     a = spiral(3, 3, 3)
     x, y = next(a)
     x, y координаты центра, n - количество слоев """
    x = [x]
    y = [y]
    end = y[0] + n + 1
    xy = [y, x, y, x]  # у - по вертикали, x - по горизонтали
    where = [1, 1, -1, -1]  # Движение: вниз, вправо, вверх, налево
    stop = [xy[i][0]+where[i] for i in range(4)]
    i = 0
    while y[0] < end:
        while True:
            yield (x[0], y[0])
            xy[i][0] = xy[i][0] + where[i]
            if xy[i][0] == stop[i]:
                stop[i] = stop[i] + where[i]
                break
        i = (i + 1) % 4


storona = len(matrix_copy)

# Инициализируем генератор
# Первые 2 аргумента - это координаты, вокруг которых вычисляются круги
# 3 аргумент количество кругов
# Координаты могут быть любыми, генератор будет возвращать правильные значения
a = spiral(storona//2, storona//2, 3)

# Это просто тестовый цикл. Он демонстрирует состояние матрицы после каждого изменения:
# просим у генератора координаты очередной точки, записываем по этим координатам значение отличное от начального,
# печатаем матрицу. Так можно наглядно отследить какие точки возвращает генератор.
# Тут генератор используется в цикле, как обычный список.
for i in a:
    matrix[i[1]][i[0]] = '*'  # Меняем матрицу
    # Печать матрицы
    for j in matrix:
        print(*j)
    print()
