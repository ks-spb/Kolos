# ----------------------------------------------------------------------------
# * Определяется местоположение курсора мыши
# * Делается снимок 50х50 пикс и определяется, какой из цветом является фоном, а какой объектом
# * Находится ближайший объект с помощью обхода по спирали
# * Объект закрашивается с помощью соответствующего алгоритма
# * Определяется левая верхняя точка курсора (или может будет лучше центральная?)
# * Сохраняются координаты этой начальной точки, для последующего повторного запуска алгоритма закрашивания
# ----------------------------------------------------------------------------
# 1. Получить координаты клика мыши
# 2. Сделан скриншот области вокруг клика мыши
# 3. Преобразовать скриншот в матрицу из 1 и 0, где 0 — это фон, 1 — точки объекта
# 4. Методом спирали найти ближайшую к клику мыши точку объекта
# 5. Получить список кортежей смещений каждой точки объекта относительно левой верхней точки квадрата скриншота.
#    Полученный список теперь содержит только один объект, точка которого была найдена в п.4. Он мог находиться
#    в центре сделанного скриншота.
# 6. Найти минимальное значение координат по горизонтали и вертикали
# 7. Уменьшить все координаты горизонтали и вертикали на их минимальные значения. Таким образом сдвигаем объект в
#    верхний левый угол.
# 8. Ширина описывающего прямоугольника — макс. Горизонтальное смещение + 1, высота макс. Вертикальное смещение + 1.
# 9. Координаты верхнего левого угла прямоугольника (объекта) на экране — координаты скриншота +
#    значения найденные в п.6.
# 10. При необходимости можно получить квадрат с нечетным количеством точек из прямоугольника. Для этого найти максимум
#     между горизонтальными и вертикальными координатами. Если нужно увеличить его до нечетного значения. Это и будет
#     сторона искомого квадрата. Его центр длина стороны деленная на 2 без остатка.



import os, sys
import datetime
import numpy as np
import pyautogui
from pynput import keyboard
import cv2
from PIL import Image


REGION = 20  # Сторона квадрата с сохраняемым элементом. Ставить нечетным!
BASENAME = "elem"  # Префикс для имени файла при сохранении изображения элемента
PATH = input_file = os.path.join(sys.path[0], 'elements_img')  # Путь для сохранения изображений
FILENAME = ""  # Имя файла, в котором хранится изображение элемента
SCR_XY = (0, 0)  # Координаты на экране левого верхнего угла квадрата с сохраняемым элементом

def screenshot(x_reg: int = 0, y_reg: int = 0, region: int = 0):
    """ Скриншот заданного квадрата или всего экрана

    В качестве аргументов принимает координаты верхней левой точки квадрата и его стороны.
    Если сторона на задана (равна 0) - то делает скриншот всего экрана

    """
    if region:
        image = pyautogui.screenshot(region=(x_reg, y_reg, region, region))  # x, y, x+n, y+n (с верхнего левого угла)
    else:
        image = pyautogui.screenshot()
    return cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)


def save_image():
    """
    Функция определяет положение курсора мыши, делает скриншот квадрата с заданными размерами и сохраняет файл с img
    """
    global SCR_XY
    x_pos, y_pos = pyautogui.position()
    # print('Позиция мыши следующая: ', x_pos, y_pos)

    # Делаем скриншот нужного квадрата, где центр - координаты мыши
    SCR_XY = (x_pos-REGION//2, y_pos-REGION//2)
    image = screenshot(*SCR_XY, REGION)

    # скриншот целого экрана
    # image = screenshot()

    x = y = 0
    w = h = REGION

    # Сохраняем изображение найденного элемента
    ROI = image[y:y_pos + h, x:x_pos + w]
    suffix = datetime.datetime.now().strftime("%y%m%d_%H%M%S")
    filename = f'{"_".join([BASENAME, suffix])}.png'
    cv2.imwrite(os.path.join(PATH, filename), ROI)

    return filename

def preobrazovanie_img(filename):
    """
    Функция открывает файл с сохранённым изображением, преобразовывает в ч/б и сохраняет в csv
    """

    img = np.asarray(Image.open(os.path.join(PATH, filename)))

    image = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2BGR)

    # преобразовать изображение в формат оттенков серого
    img_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Применение бинарного порога к изображению
    ret, thresh = cv2.threshold(img_gray, 100, 255, cv2.THRESH_BINARY)

    # сохранение scv файла в цвете в csv:
    # np.savetxt(f"{PATH}/{filename}.csv", img.reshape(REGION, -1), delimiter=",", fmt="%s", header=str(img.shape))

    # np.savetxt(f"{os.path.join(PATH, filename)}.csv", thresh, delimiter=" ,", fmt=" %.0f ")  # сохранение в csv-файл
    # print('thresh:\n', thresh)

    return thresh

def save_matrix(thresh):
    """ Точки объектов - 1, фон - 0, сохраняет матрицу в файл Preobrazovanniy"""

    thresh[thresh == 255] = 1  # Меняем в массиве 255 на 1

    # Определяем, что является чернилами
    ink = 1 if sum(np.sum(i == 1) for i in thresh) < (len(thresh) * len(thresh[0])) // 2 else 0

    # Меняем чернила на 1, а фон на 0
    if not ink:
        mask = thresh ^ 1
        thresh = mask.astype(np.uint8)


    filename = "Preobrazovanniy"

    np.savetxt(f"{os.path.join(PATH, filename)}.csv", thresh, delimiter=" ,", fmt=" %.0f ")  # сохранение в csv-файл

    return thresh


def spiral(x, y, n):
    """ Это функция генератор, ее надо инициализировать и далее с помощью оператора next получать координаты
     a = spiral(3, 3, 3)
     x, y = next(a)
     x, y координаты центра, n - количество слоев """
    x = [x]
    y = [y]
    end = y[0] + n + 1
    xy = [y, x, y, x]  # у - по вертикали, x - по горизонтали
    where = [1, 1, -1, -1]  # Движение: вниз, вправо, вверх, налево
    stop = [xy[i][0]+where[i] for i in range(4)]
    i = 0
    while y[0] < end:
        while True:
            yield (x[0], y[0])
            xy[i][0] = xy[i][0] + where[i]
            if xy[i][0] == stop[i]:
                stop[i] = stop[i] + where[i]
                break
        i = (i + 1) % 4


def fill(matrix, x, y):
    """ Обход точек и формирование списка смещения каждой относительно верхнего левого угла 0, 0"""
    out = []
    stack = [(x, y)]
    while stack:
        x, y = stack.pop()
        if matrix[x][y] == 1:
            matrix[x][y] = 2
            out.append((x, y))
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == dy == 0:
                        continue
                    new_x = x + dx
                    new_y = y + dy
                    if 0 <= new_x < matrix.shape[0] and 0 <= new_y < matrix.shape[1]:
                        stack.append((new_x, new_y))
    return out

# 1. Получить координаты клика мыши
# 2. Сделан скриншот области вокруг клика мыши
# ----------------------------------------------------------------------------
# Это только для демонстрации. Ждет нажатия пробела, чтобы сделать скриншот
print('Наведите курсор на объект,\nНажмите Ctrl, чтобы сделать скриншот\n')
def on_press(key):
    # if key == keyboard.Key.ctrl:
    global FILENAME
    FILENAME = save_image()
    listener.stop()

with keyboard.Listener(on_press=on_press) as listener:
    listener.join()
# ----------------------------------------------------------------------------

# 3. Преобразовать скриншот в матрицу из 1 и 0, где 0 — это фон, 1 — точки объекта
matrix = preobrazovanie_img(FILENAME)
matrix = save_matrix(matrix)

# 4. Методом спирали найти ближайшую к клику мыши точку объекта
sp = spiral(REGION//2, REGION//2, 3)
try:
    while True:
        x, y = next(sp)
        if matrix[x][y] == 1:
            # print(' Координаты точки:', x, y)
            break
except StopIteration:
    print('Не найдено точки объекта')
    exit()

print('\nИсходный скриншот\n', matrix)

# 5. Получить список кортежей смещений каждой точки объекта относительно левой верхней точки квадрата скриншота.
#    Полученный список теперь содержит только один объект, точка которого была найдена в п.4. Он мог находиться
#    в центре сделанного скриншота.
offset = fill(matrix, x, y)

# 6. Найти минимальное значение смещений по горизонтали и вертикали
min_y = min(offset, key=lambda x: x[0])[0]
min_x = min(offset, key=lambda x: x[1])[1]

# 7. Уменьшить все координаты горизонтали и вертикали на их минимальные значения. Таким образом сдвигаем объект в
#    верхний левый угол.
offset = [(y - min_y, x - min_x) for y, x in offset]

# 8. Ширина описывающего прямоугольника — макс. горизонтальное смещение + 1, высота макс. вертикальное смещение + 1.
width = max(offset, key=lambda x: x[1])[1] + 1
height = max(offset, key=lambda x: x[0])[0] + 1
print()
print(f'Ширина: {width}')
print(f'Высота: {height}')

# Восстановить рисунок из списка смещений в матрице минимальных размеров
matrix = np.zeros((height, width), dtype=int)
for dx, dy in offset:
    matrix[dx][dy] = 1
print('\nВыбранный объект в матрице минимальных размеров\n', matrix)

# 9. Координаты верхнего левого угла прямоугольника (объекта) на экране — координаты скриншота +
#    значения найденные в п.6.
print('\nКоординаты верхнего левого угла прямоугольника (объекта) на экране')
print(SCR_XY[0] + min_x, SCR_XY[1] + min_y)
print(offset)
